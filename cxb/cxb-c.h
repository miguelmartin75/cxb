#pragma once

// C-compatible interface for cxb. Generated by extracting the C portions of cxb/cxb.h.
// When CXB_SKIP_C_TYPES is defined before including this header, type definitions
// are skipped. This allows the C++ header (cxb.h) to re-declare the same POD
// structs with additional C++ methods without conflicting redefinitions.

/* SECTION: includes */
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

/* SECTION: macros */
#ifndef CXB_EXPORT
#define CXB_EXPORT
#endif
#ifndef CXB_INTERNAL
#define CXB_INTERNAL static
#endif

#if defined(__clang__)
#define BREAKPOINT() __builtin_debugtrap()
#elif defined(__GNUC__)
#define BREAKPOINT() __builtin_trap()
#else
#define BREAKPOINT() abort()
#endif

#define ASSERT(x, msg)    \
    if(!(x)) BREAKPOINT()
#define REQUIRES(x)       \
    if(!(x)) BREAKPOINT()

#define COUNTOF_LIT(a) (size_t)(sizeof(a) / sizeof(*(a)))
#define LENGTHOF_LIT(s) (COUNTOF_LIT(s) - 1)

// CXB_C_EXPORT is left empty because the entire header is wrapped in an extern
// "C" block (see above). This avoids duplicate `extern "C"` specifiers that
// would otherwise lead to a compilation error.
#define CXB_C_EXPORT
#define CXB_C_IMPORT

/* SECTION: primitive typedefs (needed for the public API) */
typedef uint8_t  byte8;
typedef float    f32;
typedef double   f64;
typedef int32_t  i32;
typedef int64_t  i64;
typedef uint8_t  u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef struct Allocator  Allocator;
typedef struct Mallocator Mallocator;

/* ------------------------------------------------------------------------- */
/* Optionally skip concrete type definitions (used by the C++ wrapper). */
/* ------------------------------------------------------------------------- */
#ifdef CXB_SKIP_C_TYPES

// Forward declarations only â€“ concrete definitions are provided by cxb.h.
typedef struct StringSlice StringSlice;
typedef struct MString     MString;

#else /* !defined(CXB_SKIP_C_TYPES) */

/* SECTION: data structures */

// --- StringSlice ---------------------------------------------------------- //
typedef struct StringSlice {
    char* data;
    union {
        struct {
            size_t len       : 62;
            bool   null_term : 1;
        };
        size_t metadata;
    };
} StringSlice;

// --- MString -------------------------------------------------------------- //
typedef struct MString {
    char*     data;
    union {
        struct {
            size_t len       : 62;
            bool   null_term : 1;
        };
        size_t metadata;
    };
    Allocator* allocator;
} MString;

#endif /* CXB_SKIP_C_TYPES */

/* ------------------------------------------------------------------------- */
/* Public/global variables                                                   */
/* ------------------------------------------------------------------------- */
CXB_C_EXPORT extern Mallocator default_alloc;

/* ------------------------------------------------------------------------- */
/* Inline C helper functions for StringSlice                                 */
/* ------------------------------------------------------------------------- */
#ifndef CXB_SKIP_C_TYPES
CXB_C_EXPORT static inline size_t cxb_ss_size(StringSlice s) {
    return s.len;
}
CXB_C_EXPORT static inline size_t cxb_ss_n_bytes(StringSlice s) {
    return s.len + (size_t)s.null_term;
}
CXB_C_EXPORT static inline bool cxb_ss_empty(StringSlice s) {
    return s.len == 0;
}
CXB_C_EXPORT static inline const char* cxb_ss_c_str(StringSlice s) {
    return s.null_term ? s.data : NULL;
}
CXB_C_EXPORT static inline StringSlice cxb_ss_slice(StringSlice s, size_t i, size_t j) {
    REQUIRES(j >= i);
    REQUIRES(i < cxb_ss_n_bytes(s));

    size_t new_len = (j == SIZE_MAX) ? s.len - i : j - i;
    StringSlice result = {
        .data      = s.data ? s.data + i : NULL,
        .len       = new_len,
        .null_term = (bool)((i + new_len == s.len) && s.null_term),
    };
    return result;
}
CXB_C_EXPORT static inline bool cxb_ss_eq(StringSlice a, StringSlice b) {
    if(a.len != b.len) return false;
    if(a.len == 0) return true;
    return memcmp(a.data, b.data, a.len) == 0;
}
CXB_C_EXPORT static inline bool cxb_ss_neq(StringSlice a, StringSlice b) {
    return !cxb_ss_eq(a, b);
}
CXB_C_EXPORT static inline bool cxb_ss_lt(StringSlice a, StringSlice b) {
    size_t n = (a.len < b.len) ? a.len : b.len;
    for(size_t idx = 0; idx < n; ++idx) {
        if(a.data[idx] < b.data[idx]) return true;
        if(a.data[idx] > b.data[idx]) return false;
    }
    return a.len < b.len;
}
CXB_C_EXPORT static inline char cxb_ss_back(StringSlice s) {
    REQUIRES(s.len > 0);
    return s.data[s.len - 1];
}

/* ------------------------------------------------------------------------- */
/* Inline C helper functions for MString                                      */
/* ------------------------------------------------------------------------- */
CXB_C_EXPORT static inline size_t cxb_mstring_size(MString s) {
    return s.len;
}
CXB_C_EXPORT static inline size_t cxb_mstring_n_bytes(MString s) {
    return s.len + (size_t)s.null_term;
}
CXB_C_EXPORT static inline bool cxb_mstring_empty(MString s) {
    return s.len == 0;
}
CXB_C_EXPORT static inline const char* cxb_mstring_c_str(MString s) {
    return s.null_term ? s.data : NULL;
}
CXB_C_EXPORT static inline bool cxb_mstring_eq(MString a, MString b) {
    if(a.len != b.len) return false;
    if(a.len == 0) return true;
    return memcmp(a.data, b.data, a.len) == 0;
}
CXB_C_EXPORT static inline bool cxb_mstring_neq(MString a, MString b) {
    return !cxb_mstring_eq(a, b);
}
CXB_C_EXPORT static inline bool cxb_mstring_lt(MString a, MString b) {
    size_t n = (a.len < b.len) ? a.len : b.len;
    int cmp = memcmp(a.data, b.data, n);
    if(cmp < 0) return true;
    if(cmp > 0) return false;
    return a.len < b.len;
}
CXB_C_EXPORT static inline char cxb_mstring_back(MString s) {
    REQUIRES(s.len > 0);
    return s.data[s.len - 1];
}
#endif /* CXB_SKIP_C_TYPES */

/* ------------------------------------------------------------------------- */
/* Non-inline C API (defined in cxb.cpp)                                     */
/* ------------------------------------------------------------------------- */
CXB_C_EXPORT void cxb_mstring_destroy(MString* s);
CXB_C_EXPORT void cxb_mstring_ensure_capacity(MString* s, size_t cap);
CXB_C_EXPORT void cxb_mstring_resize(MString* s, size_t size);
CXB_C_EXPORT void cxb_mstring_extend(MString* s, StringSlice slice);
CXB_C_EXPORT void cxb_mstring_push_back(MString* s, char val);
CXB_C_EXPORT char* cxb_mstring_push(MString* s);
CXB_C_EXPORT void cxb_mstring_reserve(MString* s, size_t cap);
CXB_C_EXPORT void cxb_mstring_ensure_null_terminated(MString* s);
CXB_C_EXPORT MString cxb_mstring_copy(MString s, Allocator* to_allocator);

/* ------------------------------------------------------------------------- */
/* Convenience literal macros                                                */
/* ------------------------------------------------------------------------- */
#define S8_LIT(s)   (StringSlice{ .data = (char*)&(s)[0], .len = LENGTHOF_LIT(s), .null_term = true })
#define S8_DATA(c,l) (StringSlice{ .data = (char*)&(c)[0], .len = (l), .null_term = false })
#ifdef __cplusplus
#define S8_STR(s)  (StringSlice{ .data = (char*)(s).c_str(), .len = (size_t)(s).size(), .null_term = true })
#define S8_CSTR(s) (StringSlice{ .data = (char*)(s), .len = (size_t) strlen(s), .null_term = true })
#endif